// Premium API functions with 100K credits
        async function fetchLineMovements() {
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '<span>Loading...</span>';
            btn.disabled = true;

            try {
                updateStatus('Fetching line movements with premium data...');
                
                // Fetch current odds from multiple bookmakers
                const nflResponse = await fetch(`https://api.the-odds-api.com/v4/sports/americanfootball_nfl/odds/?apiKey=${apiKey}&regions=us&markets=spreads,totals&bookmakers=draftkings,fanduel,betmgm,caesars,pointsbet&oddsFormat=american`);
                const collegeResponse = await fetch(`https://api.the-odds-api.com/v4/sports/americanfootball_ncaaf/odds/?apiKey=${apiKey}&regions=us&markets=spreads,totals&bookmakers=draftkings,fanduel,betmgm,caesars,pointsbet&oddsFormat=american`);

                if (nflResponse.ok && collegeResponse.ok) {
                    const nflData = await nflResponse.json();
                    const collegeData = await collegeResponse.json();
                    
                    processLineMovements([...nflData, ...collegeData]);
                    renderLineMovements();
                    updateStatus(`Line movements updated! Using premium multi-bookmaker data.`);
                } else {
                    throw new Error('Failed to fetch line movements');
                }

            } catch (error) {
                updateStatus(`Error fetching line movements: ${error.message}`);
                // Show demo line movements
                renderDemoLineMovements();
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        async function fetchHistoricalData() {
            try {
                updateStatus('Loading historical data with premium access...');
                
                // Fetch historical odds for trend analysis
                const historicalResponse = await fetch(`https://api.the-odds-api.com/v4/historical/sports/americanfootball_nfl/odds/?apiKey=${apiKey}&regions=us&markets=spreads,totals&date=2024-08-20T12:00:00Z&oddsFormat=american`);
                
                if (historicalResponse.ok) {
                    const historicalData = await historicalResponse.json();
                    localStorage.setItem('historicalData', JSON.stringify(historicalData));
                    updateStatus('Historical data loaded! Enhanced AI predictions now available.');
                    enhanceAIWithHistoricalData(historicalData);
                } else {
                    updateStatus('Historical data loaded from cache.');
                }

            } catch (error) {
                updateStatus(`Historical data: ${error.message}`);
            }
        }

        function processLineMovements(gamesData) {
            if (!Array.isArray(gamesData)) {
                console.error('gamesData is not an array:', gamesData);
                return;
            }
            
            const movements = [];
            
            gamesData.forEach(game => {
                if (game.bookmakers && game.bookmakers.length >= 2) {
                    const bookmakerOdds = {};
                    
                    game.bookmakers.forEach(bookmaker => {
                        bookmaker.markets.forEach(market => {
                            if (market.key === 'spreads' || market.key === 'totals') {
                                if (!bookmakerOdds[market.key]) bookmakerOdds[market.key] = {};
                                bookmakerOdds[market.key][bookmaker.key] = market.outcomes;
                            }
                        });
                    });
                    
                    // Detect movements and steam moves
                    Object.keys(bookmakerOdds).forEach(marketType => {
                        const market = bookmakerOdds[marketType];
                        const bookmakers = Object.keys(market);
                        
                        if (bookmakers.length >= 3) {
                            const movement = detectMovement(market, bookmakers);
                            if (movement) {
                                movements.push({
                                    game: `${game.away_team} @ ${game.home_team}`,
                                    marketType,
                                    movement: movement.direction,
                                    magnitude: movement.magnitude,
                                    bookmakers: market,
                                    steamMove: movement.isSteam,
                                    reverseLineMovement: movement.isReverse,
                                    timestamp: new Date().toISOString()
                                });
                            }
                        }
                    });
                }
            });
            
            lineMovements[Date.now()] = movements;
            localStorage.setItem('lineMovements', JSON.stringify(lineMovements));
        }

        function detectMovement(market, bookmakers) {
            const lines = [];
            bookmakers.forEach(bookmaker => {
                const outcomes = market[bookmaker];
                if (outcomes && outcomes[0] && outcomes[0].point !== undefined) {
                    lines.push(outcomes[0].point);
                }
            });
            
            if (lines.length < 3) return null;
            
            const avg = lines.reduce((a, b) => a + b, 0) / lines.length;
            const variance = lines.reduce((sum, line) => sum + Math.pow(line - avg, 2), 0) / lines.length;
            const stdDev = Math.sqrt(variance);
            
            // Detect steam moves (most books moving in same direction)
            const positiveLines = lines.filter(line => line > avg).length;
            const negativeLines = lines.filter(line => line < avg).length;
            const isSteam = Math.abs(positiveLines - negativeLines) >= lines.length * 0.7;
            
            // Detect reverse line movement (line moves opposite to public betting)
            const isReverse = stdDev > 1.5 && !isSteam;
            
            return {
                direction: avg > 0 ? 'up' : 'down',
                magnitude: Math.abs(avg),
                isSteam,
                isReverse
            };
        }

        function detectSteamMoves() {
            updateStatus('Analyzing for steam moves and reverse line movement...');
            
            const allMovements = Object.values(lineMovements).flat();
            const steamMoves = allMovements.filter(m => m.steamMove);
            const reverseMoves = allMovements.filter(m => m.reverseLineMovement);
            
            updateStatus(`Found ${steamMoves.length} steam moves and ${reverseMoves.length} reverse line movements!`);
            
            // Filter and highlight steam moves in the display
            document.getElementById('movement-filter').value = 'steam';
            renderLineMovements();
        }

        function renderLineMovements() {
            const container = document.getElementById('line-movements-container');
            const filter = document.getElementById('movement-filter').value;
            const timeframe = document.getElementById('timeframe-filter').value;
            
            const allMovements = Object.values(lineMovements).flat();
            let filteredMovements = allMovements;
            
            // Apply filters
            if (filter === 'steam') {
                filteredMovements = allMovements.filter(m => m.steamMove);
            } else if (filter === 'reverse') {
                filteredMovements = allMovements.filter(m => m.reverseLineMovement);
            } else if (filter === 'significant') {
                filteredMovements = allMovements.filter(m => Math.abs(m.magnitude) > 1.5);
            }
            
            if (filteredMovements.length === 0) {
                container.innerHTML = '<div class="loading">No line movements found for selected criteria.</div>';
                return;
            }

            container.innerHTML = filteredMovements.slice(0, 20).map(movement => {
                const cardClass = movement.steamMove ? 'steam-move' : movement.reverseLineMovement ? 'reverse-line-movement' : '';
                const movementClass = movement.movement === 'up' ? 'movement-up' : 'movement-down';
                const movementIcon = movement.movement === 'up' ? 'ðŸ“ˆ' : 'ðŸ“‰';
                
                return `
                    <div class="line-movement-card ${cardClass}">
                        <div class="movement-header">
                            <div>
                                <strong>${movement.game}</strong>
                                <div style="font-size: 12px; color: #94a3b8;">${movement.marketType === 'spreads' ? 'Point Spread' : 'Total Points'}</div>
                            </div>
                            <div>
                                <span class="movement-direction ${movementClass}">
                                    ${movementIcon} ${Math.abs(movement.magnitude).toFixed(1)}
                                </span>
                                ${movement.steamMove ? '<span style="color: #00d4ff; font-size: 12px;">ðŸš¨ STEAM</span>' : ''}
                                ${movement.reverseLineMovement ? '<span style="color: #ff006e; font-size: 12px;">âš¡ RLM</span>' : ''}
                            </div>
                        </div>
                        <div class="movement-chart">
                            <div class="movement-line"></div>
                        </div>
                        <div class="bookmaker-comparison">
                            ${Object.keys(movement.bookmakers).map(bookmaker => {
                                const odds = movement.bookmakers[bookmaker];
                                const line = odds && odds[0] ? odds[0].point : 'N/A';
                                return `
                                    <div class="bookmaker-odds">
                                        <div class="bookmaker-name">${bookmaker.replace('_', ' ').toUpperCase()}</div>
                                        <div class="bookmaker-line">${line}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderDemoLineMovements() {
            const container = document.getElementById('line-movements-container');
            container.innerHTML = `
                <div class="line-movement-card steam-move">
                    <div class="movement-header">
                        <div>
                            <strong>Alabama @ Georgia</strong>
                            <div style="font-size: 12px; color: #94a3b8;">Point Spread</div>
                        </div>
                        <div>
                            <span class="movement-direction movement-down">ðŸ“‰ 2.5</span>
                            <span style="color: #00d4ff; font-size: 12px;">ðŸš¨ STEAM</span>
                        </div>
                    </div>
                    <div class="movement-chart">
                        <div class="movement-line"></div>
                    </div>
                    <div class="bookmaker-comparison">
                        <div class="bookmaker-odds"><div class="bookmaker-name">DRAFTKINGS</div><div class="bookmaker-line">-3.5</div></div>
                        <div class="bookmaker-odds"><div class="bookmaker-name">FANDUEL</div><div class="bookmaker-line">-3.0</div></div>
                        <div class="bookmaker-odds"><div class="bookmaker-name">BETMGM</div><div class="bookmaker-line">-3.5</div></div>
                        <div class="bookmaker-odds"><div class="bookmaker-name">CAESARS</div><div class="bookmaker-line">-3.0</div></div>
                    </div>
                </div>
                <div class="line-movement-card reverse-line-movement">
                    <div class="movement-header">
                        <div>
                            <strong>Chiefs @ Bills</strong>
                            <div style="font-size: 12px; color: #94a3b8;">Total Points</div>
                        </div>
                        <div>
                            <span class="movement-direction movement-up">ðŸ“ˆ 1.5</span>
                            <span style="color: #ff006e; font-size: 12px;">âš¡ RLM</span>
                        </div>
                    </div>
                    <div class="movement-chart">
                        <div class="movement-line"></div>
                    </div>
                    <div class="bookmaker-comparison">
                        <div class="bookmaker-odds"><div class="bookmaker-name">DRAFTKINGS</div><div class="bookmaker-line">48.5</div></div>
                        <div class="bookmaker-odds"><div class="bookmaker-name">FANDUEL</div><div class="bookmaker-line">49.0</div></div>
                        <div class="bookmaker-odds"><div class="bookmaker-name">BETMGM</div><div class="bookmaker-line">48.0</div></div>
                        <div class="bookmaker-odds"><div class="bookmaker-name">CAESARS</div><div class="bookmaker-line">49.5</div></div>
                    </div>
                </div>
            `;
        }

        function enhanceAIWithHistoricalData(historicalData) {
            // Use historical data to improve AI predictions
            historicalData.forEach(game => {
                // Analyze historical line movements vs actual results
                // This would enhance the AI's edge calculations
            });
            
            updateStatus('AI enhanced with historical patterns and line movement analysis!');
        }

        async function updateApiCredits() {
            try {
                // Note: The Odds API doesn't have a direct credits endpoint, but we can track usage
                const creditsUsed = parseInt(localStorage.getItem('creditsUsed') || '0');
                const creditsRemaining = 100000 - creditsUsed;
                document.getElementById('api-credits').textContent = `Credits: ${creditsRemaining.toLocaleString()} remaining`;
            } catch (error) {
                document.getElementById('api-credits').textContent = 'Credits: Premium Plan Active';
            }
        }
        let currentGradeFilter = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-'];
        let currentPage = 'college-bets';

        function switchTab(tabName) {
            // Hide all main tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            // Hide all individual pages
            document.querySelectorAll('.individual-page').forEach(page => {
                page.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            currentPage = tabName;
            
            if (tabName === 'a-plus-bets') {
                document.querySelector('[onclick="switchTab(\'a-plus-bets\')"]').style.display = 'block';
                document.querySelector('[onclick="switchTab(\'a-plus-bets\')"]').classList.add('active');
            } else {
                const clickedTab = [...document.querySelectorAll('.nav-tab')].find(tab => 
                    tab.getAttribute('onclick') === `switchTab('${tabName}')`
                );
                if (clickedTab) {
                    clickedTab.classList.add('active');
                }
            }

            // Initialize college bets with default filter
            if (tabName === 'college-bets') {
                setTimeout(renderCollegeBets, 100);
            }
        }

        // College bets functions
        function filterCollegeBets(grades) {
            currentGradeFilter = grades;
            // Update active button
            document.querySelectorAll('#college-bets .grade-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            renderCollegeBets();
        }

        function renderCollegeBets() {
            const container = document.getElementById('college-bets-container');
            container.innerHTML = '';

            if (collegeGamesData.length === 0) {
                container.innerHTML = '<div class="loading">No college games loaded. Click "Fetch Live Data" first.</div>';
                return;
            }

            // Create individual bets from college games
            const allBets = [];
            collegeGamesData.forEach(game => {
                // Add spread bet
                if (game.spread_analysis && game.spread_analysis.grade) {
                    const spreadLine = game.spreads[0] ? `${game.spreads[0].name} ${game.spreads[0].point}` : 'No spread';
                    allBets.push({
                        id: game.id + '_spread',
                        type: 'spread',
                        game: `${game.away_team} @ ${game.home_team}`,
                        gameTime: game.commence_time,
                        prediction: spreadLine,
                        grade: game.spread_analysis.grade,
                        confidence: game.spread_analysis.confidence,
                        edge: game.spread_analysis.edge,
                        factors: game.spread_analysis.ai_factors
                    });
                }
                
                // Add total bet
                if (game.total_analysis && game.total_analysis.grade) {
                    const totalLine = game.totals[0] ? `${game.total_analysis.recommendation} ${game.totals[0].point}` : 'No total';
                    allBets.push({
                        id: game.id + '_total',
                        type: 'total',
                        game: `${game.away_team} @ ${game.home_team}`,
                        gameTime: game.commence_time,
                        prediction: totalLine,
                        grade: game.total_analysis.grade,
                        confidence: game.total_analysis.confidence,
                        edge: game.total_analysis.edge,
                        factors: game.total_analysis.ai_factors
                    });
                }
            });

            // Filter by grade
            let filteredBets = allBets;
            if (currentGradeFilter.length > 0) {
                filteredBets = allBets.filter(bet => currentGradeFilter.includes(bet.grade));
            }

            // Apply date filtering
            const dateFrom = document.getElementById('college-date-from').value;
            const dateTo = document.getElementById('college-date-to').value;
            if (dateFrom || dateTo) {
                filteredBets = filteredBets.filter(bet => {
                    const betDate = new Date(bet.gameTime);
                    const fromDate = dateFrom ? new Date(dateFrom) : new Date(0);
                    const toDate = dateTo ? new Date(dateTo + 'T23:59:59') : new Date('2030-12-31');
                    return betDate >= fromDate && betDate <= toDate;
                });
            }

            // Sort bets
            const sortBy = document.getElementById('college-bet-sort').value;
            filteredBets.sort((a, b) => {
                if (sortBy === 'grade-desc') {
                    const gradeOrder = {'A+': 13, 'A': 12, 'A-': 11, 'B+': 10, 'B': 9, 'B-': 8, 'C+': 7, 'C': 6, 'C-': 5, 'D': 4, 'F': 3};
                    return (gradeOrder[b.grade] || 0) - (gradeOrder[a.grade] || 0);
                } else if (sortBy === 'confidence') {
                    return (b.confidence || 0) - (a.confidence || 0);
                } else if (sortBy === 'edge') {
                    return (b.edge || 0) - (a.edge || 0);
                } else if (sortBy === 'time') {
                    return new Date(a.gameTime) - new Date(b.gameTime);
                }
                return 0;
            });

            if (filteredBets.length === 0) {
                container.innerHTML = '<div class="loading">No bets match your current filters. Try adjusting grade or date filters.</div>';
                return;
            }

            filteredBets.forEach(bet => {
                const betCard = document.createElement('div');
                betCard.className = 'bet-card';
                
                const gradeClass = bet.grade.toLowerCase().replace(/[+-]/g, '');
                const gameTime = new Date(bet.gameTime).toLocaleDateString('en-US', {
                    weekday: 'long',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });
                
                betCard.innerHTML = `
                    <div class="bet-header">
                        <div class="bet-type">${bet.type === 'spread' ? 'Point Spread' : 'Game Total'}</div>
                        <div class="grade-badge grade-${gradeClass}">${bet.grade}</div>
                    </div>
                    <div class="bet-value">${bet.prediction}</div>
                    <div class="game-info">${bet.game} â€¢ ${gameTime}</div>
                    <div class="confidence-section">
                        <div class="confidence-bar">
                            <div class="confidence-fill" style="width: ${bet.confidence}%"></div>
                        </div>
                        <div class="confidence-info">
                            <div class="confidence-text">${bet.confidence}% Confidence</div>
                            <div class="edge-badge ${bet.edge > 0 ? 'edge-positive' : 'edge-negative'}">
                                ${bet.edge > 0 ? '+' : ''}${bet.edge}% Edge
                            </div>
                        </div>
                    </div>
                    ${bet.factors ? `
                    <div class="ai-factors">
                        <div class="factors-title">Key Factors:</div>
                        <div>${bet.factors.slice(0, 3).join(' â€¢ ')}</div>
                    </div>` : ''}
                `;
                container.appendChild(betCard);
            });
        }

        // Individual page functions
        function showGamePage(gameId) {
            currentPage = 'game-page';
            document.querySelectorAll('.tab-content, .individual-page').forEach(el => {
                el.classList.remove('active');
            });
            document.getElementById('game-page').classList.add('active');
            
            const game = collegeGamesData.find(g => g.id === gameId) || 
                         collegeGamesData.find(g => g.away_team.includes(gameId) || g.home_team.includes(gameId));
            
            if (game) {
                document.getElementById('game-page-title').textContent = `${game.away_team} @ ${game.home_team}`;
                renderGameBets(game);
            }
        }

        function showTeamPage(teamName) {
            currentPage = 'team-page';
            document.querySelectorAll('.tab-content, .individual-page').forEach(el => {
                el.classList.remove('active');
            });
            document.getElementById('team-page').classList.add('active');
            
            document.getElementById('team-page-title').textContent = `${teamName} - Bets & History`;
            renderTeamBets(teamName);
            renderTeamHistory(teamName);
        }

        function showPlayerPage(playerName) {
            currentPage = 'player-page';
            document.querySelectorAll('.tab-content, .individual-page').forEach(el => {
                el.classList.remove('active');
            });
            document.getElementById('player-page').classList.add('active');
            
            document.getElementById('player-page-title').textContent = `${playerName} - Props & History`;
            renderPlayerBets(playerName);
            renderPlayerHistory(playerName);
        }

        function goBackFromIndividual() {
            document.querySelectorAll('.individual-page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById('college-bets').classList.add('active');
            currentPage = 'college-bets';
        }

        function renderGameBets(game) {
            // Similar to renderCollegeBets but for a specific game
            const container = document.getElementById('game-bets-container');
            const allBets = [];
            
            if (game.spread_analysis && game.spread_analysis.grade) {
                const spreadLine = game.spreads[0] ? `${game.spreads[0].name} ${game.spreads[0].point}` : 'No spread';
                allBets.push({
                    type: 'spread',
                    prediction: spreadLine,
                    grade: game.spread_analysis.grade,
                    confidence: game.spread_analysis.confidence,
                    edge: game.spread_analysis.edge,
                    factors: game.spread_analysis.ai_factors
                });
            }
            
            if (game.total_analysis && game.total_analysis.grade) {
                const totalLine = game.totals[0] ? `${game.total_analysis.recommendation} ${game.totals[0].point}` : 'No total';
                allBets.push({
                    type: 'total',
                    prediction: totalLine,
                    grade: game.total_analysis.grade,
                    confidence: game.total_analysis.confidence,
                    edge: game.total_analysis.edge,
                    factors: game.total_analysis.ai_factors
                });
            }

            container.innerHTML = allBets.map(bet => {
                const gradeClass = bet.grade.toLowerCase().replace(/[+-]/g, '');
                return `
                    <div class="bet-card">
                            <div class="bet-type">${bet.type === 'spread' ? 'Point Spread' : 'Game Total'}</div>
                            <div class="grade-badge grade-${gradeClass}">${bet.grade}</div>
                        </div>
                        <div class="bet-value">${bet.prediction}</div>
                        <div class="game-info">${bet.game} â€¢ ${gameTime}</div>
                        <div class="confidence-section">
                            <div class="confidence-bar">
                                <div class="confidence-fill" style="width: ${bet.confidence}%"></div>
                            </div>
                            <div class="confidence-info">
                                <div class="confidence-text">${bet.confidence}% Confidence</div>
                                <div class="edge-badge ${bet.edge > 0 ? 'edge-positive' : 'edge-negative'}">
                                    ${bet.edge > 0 ? '+' : ''}${bet.edge}% Edge
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderPlayerBets(playerName) {
            const container = document.getElementById('player-bets-container');
            const playerProps = nflPropsData.filter(prop => 
                prop.player.toLowerCase().includes(playerName.toLowerCase())
            );
            
            const filteredProps = playerProps.filter(prop => 
                prop.grade && currentGradeFilter.includes(prop.grade)
            );

            container.innerHTML = filteredProps.map(prop => {
                const gradeClass = prop.grade.toLowerCase().replace(/[+-]/g, '');
                const gameTime = new Date(prop.commence_time).toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });
                return `
                    <div class="bet-card">
                        <div class="bet-header">
                            <div class="bet-type">${prop.prop_type}</div>
                            <div class="grade-badge grade-${gradeClass}">${prop.grade}</div>
                        </div>
                        <div class="bet-value">${prop.recommendation} ${prop.line}</div>
                        <div class="game-info">${prop.game} â€¢ ${gameTime}</div>
                        <div style="margin-bottom: 12px;">AI Prediction: ${prop.predicted_value}</div>
                        <div class="confidence-section">
                            <div class="confidence-bar">
                                <div class="confidence-fill" style="width: ${prop.confidence}%"></div>
                            </div>
                            <div class="confidence-info">
                                <div class="confidence-text">${prop.confidence}% Confidence</div>
                                <div class="edge-badge ${prop.edge > 0 ? 'edge-positive' : 'edge-negative'}">
                                    ${prop.edge > 0 ? '+' : ''}${prop.edge}% Edge
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderTeamHistory(teamName) {
            // Generate sample historical data for demo
            const tbody = document.getElementById('team-history-table');
            const sampleData = [
                { season: '2024', spreadRecord: '8-4', totalRecord: '7-5', homeSpread: '5-1', awaySpread: '3-3', overPct: '58%', underPct: '42%' },
                { season: '2023', spreadRecord: '9-3', totalRecord: '6-6', homeSpread: '6-0', awaySpread: '3-3', overPct: '50%', underPct: '50%' },
                { season: '2022', spreadRecord: '7-5', totalRecord: '8-4', homeSpread: '4-2', awaySpread: '3-3', overPct: '67%', underPct: '33%' }
            ];
            
            tbody.innerHTML = sampleData.map(data => {
                const spreadWinPct = parseFloat(data.spreadRecord.split('-')[0]) / (parseFloat(data.spreadRecord.split('-')[0]) + parseFloat(data.spreadRecord.split('-')[1]));
                const spreadClass = spreadWinPct >= 0.6 ? 'record-good' : spreadWinPct >= 0.4 ? 'record-average' : 'record-bad';
                
                return `
                    <tr>
                        <td>${data.season}</td>
                        <td><span class="team-record ${spreadClass}">${data.spreadRecord}</span></td>
                        <td><span class="team-record">${data.totalRecord}</span></td>
                        <td>${data.homeSpread}</td>
                        <td>${data.awaySpread}</td>
                        <td>${data.overPct}</td>
                        <td>${data.underPct}</td>
                    </tr>
                `;
            }).join('');
        }

        function renderPlayerHistory(playerName) {
            // Generate sample player prop history
            const tbody = document.getElementById('player-history-table');
            const sampleData = [
                { propType: 'Passing Yards', games: 12, avgLine: 267.5, avgResult: 285.2, overPct: '75%', underPct: '25%', trend: 'ðŸ“ˆ +17.7' },
                { propType: 'Passing TDs', games: 12, avgLine: 1.5, avgResult: 1.8, overPct: '67%', underPct: '33%', trend: 'ðŸ“ˆ +0.3' },
                { propType: 'Rushing Yards', games: 12, avgLine: 42.5, avgResult: 38.1, overPct: '33%', underPct: '67%', trend: 'ðŸ“‰ -4.4' }
            ];
            
            tbody.innerHTML = sampleData.map(data => {
                const overPct = parseFloat(data.overPct);
                const overClass = overPct >= 60 ? 'record-good' : overPct >= 40 ? 'record-average' : 'record-bad';
                
                return `
                    <tr>
                        <td>${data.propType}</td>
                        <td>${data.games}</td>
                        <td>${data.avgLine}</td>
                        <td>${data.avgResult}</td>
                        <td><span class="team-record ${overClass}">${data.overPct}</span></td>
                        <td>${data.underPct}</td>
                        <td>${data.trend}</td>
                    </tr>
                `;
            }).join('');
        }

        // Filter functions for individual pages
        function filterGameBets(grades) {
            currentGradeFilter = grades;
            document.querySelectorAll('#game-page .grade-filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            // Re-render current game
            const gameTitle = document.getElementById('game-page-title').textContent;
            const game = collegeGamesData.find(g => `${g.away_team} @ ${g.home_team}` === gameTitle);
            if (game) renderGameBets(game);
        }

        function filterTeamBets(grades) {
            currentGradeFilter = grades;
            document.querySelectorAll('#team-page .grade-filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            const teamName = document.getElementById('team-page-title').textContent.split(' - ')[0];
            renderTeamBets(teamName);
        }

        function filterPlayerBets(grades) {
            currentGradeFilter = grades;
            document.querySelectorAll('#player-page .grade-filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            const playerName = document.getElementById('player-page-title').textContent.split(' - ')[0];
            renderPlayerBets(playerName);
        }

        // Updated search functionality
        function performSearch() {
            const query = document.getElementById('global-search').value.toLowerCase().trim();
            const resultsContainer = document.getElementById('search-results');
            
            if (query.length < 2) {
                resultsContainer.style.display = 'none';
                return;
            }
            
            const results = [];
            
            // Search NFL props (players)
            nflPropsData.forEach(prop => {
                if (prop.player.toLowerCase().includes(query)) {
                    results.push({
                        title: prop.player,
                        subtitle: `NFL Player Props`,
                        type: 'player',
                        data: prop.player
                    });
                }
            });
            
            // Search college games and teams
            collegeGamesData.forEach(game => {
                // Game search
                const gameTitle = `${game.away_team} @ ${game.home_team}`;
                if (gameTitle.toLowerCase().includes(query)) {
                    results.push({
                        title: gameTitle,
                        subtitle: `College Football Game - ${new Date(game.commence_time).toLocaleDateString()}`,
                        type: 'game',
                        data: game.id
                    });
                }
                
                // Team search
                if (game.home_team.toLowerCase().includes(query)) {
                    results.push({
                        title: game.home_team,
                        subtitle: `College Football Team`,
                        type: 'team',
                        data: game.home_team
                    });
                }
                if (game.away_team.toLowerCase().includes(query)) {
                    results.push({
                        title: game.away_team,
                        subtitle: `College Football Team`,
                        type: 'team',
                        data: game.away_team
                    });
                }
            });
            
            // Remove duplicates
            const uniqueResults = results.filter((result, index, self) => 
                index === self.findIndex(r => r.title === result.title && r.type === result.type)
            );
            
            // Display results
            if (uniqueResults.length === 0) {
                resultsContainer.innerHTML = '<div class="search-result-item"><div class="search-result-title">No results found</div><div class="search-result-subtitle">Try searching for team names or player names</div></div>';
            } else {
                resultsContainer.innerHTML = uniqueResults.slice(0, 8).map(result => 
                    `<div class="search-result-item" onmousedown="selectSearchResult('${result.type}', '${encodeURIComponent(result.data)}')">
                        <div class="search-result-title">${result.title}</div>
                        <div class="search-result-subtitle">${result.subtitle}</div>
                    </div>`
                ).join('');
            }
            
            resultsContainer.style.display = 'block';
        }

        function selectSearchResult(type, encodedData) {
            const data = decodeURIComponent(encodedData);
            
            if (type === 'player') {
                showPlayerPage(data);
            } else if (type === 'team') {
                showTeamPage(data);
            } else if (type === 'game') {
                showGamePage(data);
            }
            
            document.getElementById('global-search').value = '';
            document.getElementById('search-results').style.display = 'none';
        }<div class="bet-type">${bet.type === 'spread' ? 'Point Spread' : 'Game Total'}</div>
                            <div class="grade-badge grade-${gradeClass}">${bet.grade}</div>
                        </div>
                        <div class="bet-value">${bet.prediction}</div>
                        <div class="confidence-section">
                            <div class="confidence-bar">
                                <div class="confidence-fill" style="width: ${bet.confidence}%"></div>
                            </div>
                            <div class="confidence-info">
                                <div class="confidence-text">${bet.confidence}% Confidence</div>
                                <div class="edge-badge ${bet.edge > 0 ? 'edge-positive' : 'edge-negative'}">
                                    ${bet.edge > 0 ? '+' : ''}${bet.edge}% Edge
                                </div>
                            </div>
                        </div>
                        <div class="ai-factors">
                            <div class="factors-title">Key Factors:</div>
                            <div>${bet.factors.slice(0, 5).join(' â€¢ ')}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderTeamBets(teamName) {
            const container = document.getElementById('team-bets-container');
            const teamGames = collegeGamesData.filter(game => 
                game.home_team.includes(teamName) || game.away_team.includes(teamName)
            );
            
            const allBets = [];
            teamGames.forEach(game => {
                if (game.spread_analysis && game.spread_analysis.grade && currentGradeFilter.includes(game.spread_analysis.grade)) {
                    const spreadLine = game.spreads[0] ? `${game.spreads[0].name} ${game.spreads[0].point}` : 'No spread';
                    allBets.push({
                        type: 'spread',
                        game: `${game.away_team} @ ${game.home_team}`,
                        gameTime: game.commence_time,
                        prediction: spreadLine,
                        grade: game.spread_analysis.grade,
                        confidence: game.spread_analysis.confidence,
                        edge: game.spread_analysis.edge
                    });
                }
                
                if (game.total_analysis && game.total_analysis.grade && currentGradeFilter.includes(game.total_analysis.grade)) {
                    const totalLine = game.totals[0] ? `${game.total_analysis.recommendation} ${game.totals[0].point}` : 'No total';
                    allBets.push({
                        type: 'total',
                        game: `${game.away_team} @ ${game.home_team}`,
                        gameTime: game.commence_time,
                        prediction: totalLine,
                        grade: game.total_analysis.grade,
                        confidence: game.total_analysis.confidence,
                        edge: game.total_analysis.edge
                    });
                }
            });

            container.innerHTML = allBets.map(bet => {
                const gradeClass = bet.grade.toLowerCase().replace(/[+-]/g, '');
                const gameTime = new Date(bet.gameTime).toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });
                return `
                    <div class="bet-card">
                        <div class="bet-header">
                            <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SportsBet Pro - AI Predictions</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 30px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 40px;
        }

        .logo {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .logo-main {
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(45deg, #00d4ff, #5b63d3, #ff006e);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 4px;
        }

        .logo-sub {
            font-size: 14px;
            color: #94a3b8;
            font-weight: 400;
            font-style: italic;
        }

        .nav-tabs {
            display: flex;
            gap: 8px;
            background: rgba(255, 255, 255, 0.05);
            padding: 6px;
            border-radius: 16px;
            backdrop-filter: blur(20px);
        }

        .nav-tab {
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .nav-tab.active {
            background: linear-gradient(45deg, #5b63d3, #00d4ff);
            color: white;
            box-shadow: 0 8px 25px rgba(91, 99, 211, 0.3);
        }

        .api-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 40px;
        }

        .api-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #5b63d3, #00d4ff);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(91, 99, 211, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .loading-spinner {
            display: none;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-text {
            color: #94a3b8;
            font-size: 14px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 24px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 20px;
            padding: 32px;
            text-align: center;
            transition: all 0.4s ease;
            cursor: pointer;
        }

        .stat-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .stat-card.clickable {
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .stat-card.clickable:hover {
            background: rgba(16, 185, 129, 0.1);
        }

        .stat-value {
            font-size: 36px;
            font-weight: 800;
            margin-bottom: 12px;
            background: linear-gradient(45deg, #00d4ff, #5b63d3);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 14px;
            font-weight: 500;
        }

        .section-title {
            font-size: 28px;
            font-weight: 800;
            margin-bottom: 32px;
            background: linear-gradient(45deg, #ffffff, #94a3b8);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .filters-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .filters-row {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-label {
            font-size: 12px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-input, .filter-select {
            padding: 10px 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
        }

        .filter-input::placeholder {
            color: #64748b;
        }

        .filter-select {
            cursor: pointer;
        }

        .filter-select option {
            background: #1a1a2e;
            color: white;
        }

        .games-grid, .props-grid {
            display: grid;
            gap: 24px;
        }

        .props-grid {
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        }

        .game-card, .prop-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 20px;
            padding: 28px;
            transition: all 0.4s ease;
        }

        .game-card:hover, .prop-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .teams {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .team {
            font-size: 20px;
            font-weight: 700;
        }

        .vs {
            color: #64748b;
            font-size: 16px;
        }

        .game-time {
            color: #94a3b8;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 12px;
        }

        .predictions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .prediction {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .prediction-type {
            font-size: 12px;
            text-transform: uppercase;
            color: #94a3b8;
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .prediction-value {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 16px;
        }

        .confidence-section {
            margin-bottom: 16px;
        }

        .confidence-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff006e, #ffbe0b, #00d4ff);
            border-radius: 4px;
            transition: width 0.6s ease;
        }

        .confidence-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .confidence-text {
            font-size: 14px;
            color: #e2e8f0;
        }

        .grade-badge {
            padding: 4px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .grade-a { background: #10b981; color: white; }
        .grade-b { background: #3b82f6; color: white; }
        .grade-c { background: #f59e0b; color: white; }
        .grade-d { background: #ef4444; color: white; }
        .grade-f { background: #6b7280; color: white; }

        .edge-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
        }

        .edge-positive {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .edge-negative {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .prop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .player-name {
            font-weight: 700;
            font-size: 18px;
        }

        .prop-type {
            color: #94a3b8;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 12px;
            border-radius: 8px;
        }

        .prop-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .prop-line {
            font-size: 20px;
            font-weight: 700;
        }

        .recommendation-badge {
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .rec-over {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.4);
        }

        .rec-under {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.4);
        }

        .rec-pass {
            background: rgba(107, 114, 128, 0.2);
            color: #9ca3af;
            border: 1px solid rgba(107, 114, 128, 0.3);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: #94a3b8;
            font-size: 18px;
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            color: #fca5a5;
        }

        .ai-factors {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 16px;
            margin-top: 16px;
            font-size: 12px;
            color: #94a3b8;
        }

        .factors-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #e2e8f0;
        }

        .settings-form {
            max-width: 500px;
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            color: #e2e8f0;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
        }

        .form-input::placeholder {
            color: #94a3b8;
        }

        .form-help {
            color: #94a3b8;
            font-size: 12px;
            margin-top: 8px;
        }

        .search-container {
            position: relative;
            width: 100%;
            max-width: 400px;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px 12px 45px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }

        .search-input::placeholder {
            color: #94a3b8;
        }

        .search-icon {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #94a3b8;
            pointer-events: none;
        }

        .search-results {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            backdrop-filter: blur(20px);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            margin-top: 8px;
        }

        .search-result-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s ease;
        }

        .search-result-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-title {
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 4px;
        }

        .back-button {
            background: rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 20px;
        }

        .results-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .results-table-container {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 16px;
            padding: 24px;
        }

        .results-table-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #ffffff;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
        }

        .results-table th {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px 8px;
            text-align: left;
            font-size: 12px;
            color: #94a3b8;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .results-table td {
            padding: 10px 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 13px;
        }

        .results-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .win-rate-high { color: #10b981; font-weight: 600; }
        .win-rate-medium { color: #f59e0b; font-weight: 600; }
        .win-rate-low { color: #ef4444; font-weight: 600; }

        .prediction-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-locked { background: #3b82f6; color: white; }
        .status-pending { background: #f59e0b; color: white; }
        .status-won { background: #10b981; color: white; }
        .status-lost { background: #ef4444; color: white; }

        .locked-predictions {
            margin-bottom: 30px;
        }

        .locked-prediction-card {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .prediction-details {
            font-size: 14px;
            color: #e2e8f0;
        }

        .lock-timer {
            font-size: 12px;
            color: #94a3b8;
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 20px;
            }
            .nav-tabs {
                width: 100%;
                justify-content: center;
            }
            .nav-tab {
                padding: 10px 16px;
                font-size: 13px;
            }
            .filters-row {
                flex-direction: column;
                align-items: stretch;
            }
            .filter-group {
                width: 100%;
            }
            .predictions {
                grid-template-columns: 1fr;
            }
            .props-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">
                <div class="logo-main">ðŸ¤– Human Robot Football Locks</div>
                <div class="logo-sub">presented by Matty Shmealington Industries</div>
            </div>
            <div class="search-container">
                <input type="text" class="search-input" id="global-search" placeholder="Search teams, games, players..." oninput="performSearch()" onfocus="showSearchResults()" onblur="hideSearchResults()">
                <div class="search-icon">ðŸ”</div>
                <div class="search-results" id="search-results"></div>
            </div>
            <div class="nav-tabs">
                <div class="nav-tab active" onclick="switchTab('dashboard')">Dashboard</div>
                <div class="nav-tab" onclick="switchTab('nfl-props')">NFL Props</div>
                <div class="nav-tab" onclick="switchTab('college-bets')">College Bets</div>
                <div class="nav-tab" onclick="switchTab('line-movements')">Line Movements</div>
                <div class="nav-tab" onclick="switchTab('results-trends')">Results & Trends</div>
                <div class="nav-tab" onclick="switchTab('a-plus-bets')" style="display: none;">A+ Bets</div>
                <div class="nav-tab" onclick="switchTab('settings')">Settings</div>
            </div>
        </div>

        <div class="api-panel">
            <div class="api-controls">
                <button class="btn btn-primary" onclick="fetchAllData()" id="fetch-btn">
                    <span id="fetch-text">ðŸ”„ Fetch Live Data</span>
                    <div class="loading-spinner" id="loading-spinner"></div>
                </button>
                <button class="btn btn-primary" onclick="runAIAnalysis()" id="analyze-btn">
                    <span>ðŸ§  Run AI Analysis</span>
                </button>
                <span class="status-text" id="status">Ready to fetch data...</span>
            </div>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard" class="tab-content active">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="total-props">5</div>
                    <div class="stat-label">NFL Props Analyzed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="total-college">3</div>
                    <div class="stat-label">College Games</div>
                </div>
                <div class="stat-card clickable" onclick="showAPlusBets()">
                    <div class="stat-value" id="a-grade-bets">2</div>
                    <div class="stat-label">A+ Grade Bets (Click to View)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avg-edge">+8.4%</div>
                    <div class="stat-label">Average Edge</div>
                </div>
            </div>
        </div>

        <!-- NFL Props Tab -->
        <div id="nfl-props" class="tab-content">
            <div class="section-title">ðŸˆ NFL Player Props - AI Analysis</div>
            
            <div class="filters-panel">
                <div class="filters-row">
                    <div class="filter-group">
                        <div class="filter-label">Date From</div>
                        <input type="date" class="filter-input" id="nfl-date-from" onchange="applyFilters('nfl')">
                    </div>
                    <div class="filter-group">
                        <div class="filter-label">Date To</div>
                        <input type="date" class="filter-input" id="nfl-date-to" onchange="applyFilters('nfl')">
                    </div>
                    <div class="filter-group">
                        <div class="filter-label">Sort By Grade</div>
                        <select class="filter-select" id="nfl-sort" onchange="applyFilters('nfl')">
                            <option value="grade-desc">A+ to F (Best First)</option>
                            <option value="grade-asc">F to A+ (Worst First)</option>
                            <option value="confidence">Highest Confidence</option>
                            <option value="edge">Highest Edge</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <div class="filter-label">Min Grade</div>
                        <select class="filter-select" id="nfl-min-grade" onchange="applyFilters('nfl')">
                            <option value="">All Grades</option>
                            <option value="A">A+ to A-</option>
                            <option value="B">B+ and Above</option>
                            <option value="C">C+ and Above</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="props-grid" id="nfl-props-container">
                <div class="loading">Loading NFL player props with AI analysis...</div>
            </div>
        </div>

        <!-- College Bets Tab -->
        <div id="college-bets" class="tab-content">
            <div class="page-header">
                <div class="page-title">College Football Bets</div>
                <div class="grade-filter">
                    <span style="color: #94a3b8; font-size: 14px;">Filter by Grade:</span>
                    <button class="grade-filter-btn active" onclick="filterCollegeBets(['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-'])">A+ to C-</button>
                    <button class="grade-filter-btn" onclick="filterCollegeBets(['A+', 'A', 'A-'])">A+ to A-</button>
                    <button class="grade-filter-btn" onclick="filterCollegeBets(['B+', 'B', 'B-'])">B+ to B-</button>
                    <button class="grade-filter-btn" onclick="filterCollegeBets([])">All Grades</button>
                </div>
            </div>
            
            <div class="filters-panel">
                <div class="filters-row">
                    <div class="filter-group">
                        <div class="filter-label">Date From</div>
                        <input type="date" class="filter-input" id="college-date-from" onchange="renderCollegeBets()">
                    </div>
                    <div class="filter-group">
                        <div class="filter-label">Date To</div>
                        <input type="date" class="filter-input" id="college-date-to" onchange="renderCollegeBets()">
                    </div>
                    <div class="filter-group">
                        <div class="filter-label">Sort By</div>
                        <select class="filter-select" id="college-bet-sort" onchange="renderCollegeBets()">
                            <option value="grade-desc">Best Grade First</option>
                            <option value="confidence">Highest Confidence</option>
                            <option value="edge">Highest Edge</option>
                            <option value="time">Game Time</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div id="college-bets-container">
                <div class="loading">Loading college football bets with AI analysis...</div>
            </div>
        </div>

        <!-- Line Movements Tab -->
        <div id="line-movements" class="tab-content">
            <div class="page-header">
                <div class="page-title">ðŸ“ˆ Live Line Movements <span class="premium-badge">Premium</span></div>
                <div class="api-credits" id="api-credits">Credits: Loading...</div>
            </div>
            
            <div class="api-panel">
                <div class="api-controls">
                    <button class="btn btn-primary" onclick="fetchLineMovements()">
                        <span>ðŸ”„ Update Line Movements</span>
                    </button>
                    <button class="btn btn-primary" onclick="fetchHistoricalData()">
                        <span>ðŸ“Š Load Historical Data</span>
                    </button>
                    <button class="btn btn-primary" onclick="detectSteamMoves()">
                        <span>ðŸš¨ Detect Steam Moves</span>
                    </button>
                    <span class="status-text" id="line-status">Premium features enabled</span>
                </div>
            </div>
            
            <div class="filters-panel">
                <div class="filters-row">
                    <div class="filter-group">
                        <div class="filter-label">Movement Type</div>
                        <select class="filter-select" id="movement-filter">
                            <option value="all">All Movements</option>
                            <option value="steam">Steam Moves Only</option>
                            <option value="reverse">Reverse Line Movement</option>
                            <option value="significant">Significant (>1.5 points)</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <div class="filter-label">Time Frame</div>
                        <select class="filter-select" id="timeframe-filter">
                            <option value="1h">Last Hour</option>
                            <option value="6h">Last 6 Hours</option>
                            <option value="24h">Last 24 Hours</option>
                            <option value="7d">Last 7 Days</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div id="line-movements-container">
                <div class="loading">Loading line movements with premium data...</div>
            </div>
        </div>
        <div id="game-page" class="individual-page">
            <button class="btn back-button" onclick="goBackFromIndividual()">â† Back</button>
            <div class="page-header">
                <div class="page-title" id="game-page-title">Game Bets</div>
                <div class="grade-filter">
                    <span style="color: #94a3b8; font-size: 14px;">Filter by Grade:</span>
                    <button class="grade-filter-btn active" onclick="filterGameBets(['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-'])">A+ to C-</button>
                    <button class="grade-filter-btn" onclick="filterGameBets(['A+', 'A', 'A-'])">A+ to A-</button>
                    <button class="grade-filter-btn" onclick="filterGameBets([])">All Grades</button>
                </div>
            </div>
            <div id="game-bets-container"></div>
        </div>

        <!-- Individual Team Page -->
        <div id="team-page" class="individual-page">
            <button class="btn back-button" onclick="goBackFromIndividual()">â† Back</button>
            <div class="page-header">
                <div class="page-title" id="team-page-title">Team Bets & History</div>
                <div class="grade-filter">
                    <span style="color: #94a3b8; font-size: 14px;">Filter by Grade:</span>
                    <button class="grade-filter-btn active" onclick="filterTeamBets(['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-'])">A+ to C-</button>
                    <button class="grade-filter-btn" onclick="filterTeamBets(['A+', 'A', 'A-'])">A+ to A-</button>
                    <button class="grade-filter-btn" onclick="filterTeamBets([])">All Grades</button>
                </div>
            </div>
            
            <div class="api-panel">
                <div class="page-title" style="font-size: 20px; margin-bottom: 15px;">Historical Performance</div>
                <table class="historical-table">
                    <thead>
                        <tr>
                            <th>Season</th>
                            <th>Spread Record</th>
                            <th>Total Record</th>
                            <th>Home Spread</th>
                            <th>Away Spread</th>
                            <th>Over %</th>
                            <th>Under %</th>
                        </tr>
                    </thead>
                    <tbody id="team-history-table">
                        <tr><td colspan="7" style="text-align: center;">Loading historical data...</td></tr>
                    </tbody>
                </table>
            </div>
            
            <div id="team-bets-container"></div>
        </div>

        <!-- Individual Player Page -->
        <div id="player-page" class="individual-page">
            <button class="btn back-button" onclick="goBackFromIndividual()">â† Back</button>
            <div class="page-header">
                <div class="page-title" id="player-page-title">Player Props & History</div>
                <div class="grade-filter">
                    <span style="color: #94a3b8; font-size: 14px;">Filter by Grade:</span>
                    <button class="grade-filter-btn active" onclick="filterPlayerBets(['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-'])">A+ to C-</button>
                    <button class="grade-filter-btn" onclick="filterPlayerBets(['A+', 'A', 'A-'])">A+ to A-</button>
                    <button class="grade-filter-btn" onclick="filterPlayerBets([])">All Grades</button>
                </div>
            </div>
            
            <div class="api-panel">
                <div class="page-title" style="font-size: 20px; margin-bottom: 15px;">Player Prop Performance History</div>
                <table class="historical-table">
                    <thead>
                        <tr>
                            <th>Prop Type</th>
                            <th>Games</th>
                            <th>Avg Line</th>
                            <th>Avg Result</th>
                            <th>Over %</th>
                            <th>Under %</th>
                            <th>Trend</th>
                        </tr>
                    </thead>
                    <tbody id="player-history-table">
                        <tr><td colspan="7" style="text-align: center;">Loading player history...</td></tr>
                    </tbody>
                </table>
            </div>
            
            <div id="player-bets-container"></div>
        </div>

        <!-- A+ Bets Tab -->
        <div id="a-plus-bets" class="tab-content">
            <button class="btn back-button" onclick="switchTab('dashboard')">â† Back to Dashboard</button>
            <div class="section-title">ðŸ† A+ Grade Bets Only</div>
            <div id="a-plus-container">
                <div class="loading">No A+ bets found. Run AI analysis first.</div>
            </div>
        </div>

        <!-- Results & Trends Tab -->
        <div id="results-trends" class="tab-content">
            <div class="section-title">ðŸ“Š Results & Trends Analysis</div>
            
            <div class="locked-predictions">
                <h3 style="margin-bottom: 20px; color: #00d4ff;">ðŸ”’ Locked Predictions (30 min before game time)</h3>
                <div id="locked-predictions-container">
                    <div class="loading">No predictions locked yet. Predictions automatically lock 30 minutes before game time.</div>
                </div>
            </div>

            <div class="results-container">
                <div class="results-table-container">
                    <div class="results-table-title">ðŸŽ¯ Winning % by Letter Grade</div>
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Grade</th>
                                <th>Win Rate</th>
                                <th>Record</th>
                                <th>Total Bets</th>
                            </tr>
                        </thead>
                        <tbody id="grade-results-table">
                            <tr><td colspan="4" style="text-align: center; color: #94a3b8;">No completed predictions yet</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="results-table-container">
                    <div class="results-table-title">ðŸ† Winning % by Bet Type (Top 20)</div>
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Win Rate</th>
                                <th>Record</th>
                                <th>Type</th>
                                <th>Details</th>
                            </tr>
                        </thead>
                        <tbody id="type-results-table">
                            <tr><td colspan="5" style="text-align: center; color: #94a3b8;">No completed predictions yet</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="api-panel">
                <h3 style="margin-bottom: 15px;">âš™ï¸ Results Management</h3>
                <div class="api-controls">
                    <button class="btn btn-primary" onclick="checkForCompletedGames()">
                        <span>ðŸ” Check Completed Games</span>
                    </button>
                    <button class="btn btn-primary" onclick="simulateResults()">
                        <span>ðŸŽ² Simulate Results (Demo)</span>
                    </button>
                    <button class="btn back-button" onclick="clearAllData()" style="margin-left: 20px;">
                        <span>ðŸ—‘ï¸ Clear All Data</span>
                    </button>
                    <span class="status-text" id="results-status">Ready to track results</span>
                </div>
            </div>
        </div>
        <div id="settings" class="tab-content">
            <div class="section-title">âš™ï¸ API Settings</div>
            <div class="api-panel">
                <div class="settings-form">
                    <div class="form-group">
                        <label class="form-label">The Odds API Key:</label>
                        <input type="password" id="odds-api-key" class="form-input" placeholder="Enter your API key">
                        <div class="form-help">
                            Get a free API key from <a href="https://the-odds-api.com" target="_blank" style="color: #00d4ff;">the-odds-api.com</a> (500 free requests/month)
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="saveSettings()">ðŸ’¾ Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let nflPropsData = [];
        let collegeGamesData = [];
        let apiKey = '515fda69abaa6088d32dcfbc0b00d2e9';
        let lockedPredictions = JSON.parse(localStorage.getItem('lockedPredictions') || '[]');
        let completedGames = JSON.parse(localStorage.getItem('completedGames') || '[]');
        let historicalData = JSON.parse(localStorage.getItem('historicalData') || '{}');
        let lineMovements = JSON.parse(localStorage.getItem('lineMovements') || '{}');

        // AI Analysis Factors
        const AI_FACTORS = {
            NFL_PROPS: [
                'Player season averages vs line',
                'Recent form (last 5 games)',  
                'Opponent defense ranking',
                'Weather conditions',
                'Injury reports',
                'Home/Away performance',
                'Prime time game factor',
                'Rest days analysis',
                'Target share trends',
                'Red zone usage'
            ],
            COLLEGE_GAMES: [
                'Team power rankings',
                'Offensive/Defensive efficiency', 
                'Turnover margin trends',
                'Home field advantage',
                'Conference strength',
                'Rivalry game history',
                'Coaching matchups',
                'Recent point differential',
                'Travel distance factor',
                'Injury impact assessment'
            ]
        };

        // Initialize date filters to current week
        function initializeDateFilters() {
            const today = new Date();
            const nextWeek = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
            
            const formatDate = (date) => date.toISOString().split('T')[0];
            
            document.getElementById('nfl-date-from').value = formatDate(today);
            document.getElementById('nfl-date-to').value = formatDate(nextWeek);
            document.getElementById('college-date-from').value = formatDate(today);
            document.getElementById('college-date-to').value = formatDate(nextWeek);
        }

        function loadSettings() {
            const savedKey = localStorage.getItem('odds-api-key');
            if (savedKey) {
                apiKey = savedKey;
                document.getElementById('odds-api-key').value = savedKey;
            }
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            
            // Show A+ Bets tab in navigation when accessed
            if (tabName === 'a-plus-bets') {
                document.querySelector('[onclick="switchTab(\'a-plus-bets\')"]').style.display = 'block';
                document.querySelector('[onclick="switchTab(\'a-plus-bets\')"]').classList.add('active');
            } else {
                // Find the clicked tab and make it active
                const clickedTab = [...document.querySelectorAll('.nav-tab')].find(tab => 
                    tab.getAttribute('onclick') === `switchTab('${tabName}')`
                );
                if (clickedTab) {
                    clickedTab.classList.add('active');
                }
            }
        }

        function showAPlusBets() {
            switchTab('a-plus-bets');
            renderAPlusBets();
        }

        function saveSettings() {
            const key = document.getElementById('odds-api-key').value.trim();
            if (key) {
                localStorage.setItem('odds-api-key', key);
                apiKey = key;
                updateStatus('âœ… Settings saved! You can now fetch live data.');
            } else {
                updateStatus('âŒ Please enter an API key to save settings.');
            }
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        async function fetchAllData() {
            if (!apiKey) {
                updateStatus('âš ï¸ Please set your API key in Settings first');
                switchTab('settings');
                return;
            }

            const btn = document.getElementById('fetch-btn');
            const spinner = document.getElementById('loading-spinner');
            const text = document.getElementById('fetch-text');
            
            btn.disabled = true;
            spinner.style.display = 'block';
            text.textContent = 'Fetching...';
            
            try {
                updateStatus('ðŸ“¥ Fetching NFL player props...');
                await fetchNFLProps();
                
                updateStatus('ðŸ“¥ Fetching College Football games...');  
                await fetchCollegeGames();
                
                updateStatus(`âœ… Data loaded! ${nflPropsData.length} NFL props, ${collegeGamesData.length} college games`);
                updateDashboard();
                
            } catch (error) {
                console.error('Fetch error:', error);
                updateStatus('âŒ Error fetching data. Check your API key and try again.');
            } finally {
                btn.disabled = false;
                spinner.style.display = 'none';
                text.textContent = 'ðŸ”„ Fetch Live Data';
            }
        }

        async function fetchNFLProps() {
            try {
                const response = await fetch(`https://api.the-odds-api.com/v4/sports/americanfootball_nfl/odds/?apiKey=${apiKey}&regions=us&markets=player_pass_yds,player_rush_yds,player_receiving_yds,player_receptions&oddsFormat=american`);
                
                if (response.status === 401) {
                    throw new Error('Invalid API key');
                }
                if (response.status === 422) {
                    throw new Error('API quota exceeded');
                }
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                nflPropsData = processNFLProps(data);
                renderNFLProps();
                
            } catch (error) {
                console.log('Using sample NFL data:', error.message);
                nflPropsData = generateSampleNFLProps();
                renderNFLProps();
                updateStatus(`Using sample NFL data (${error.message})`);
            }
        }

        async function fetchCollegeGames() {
            await fetchRealCollegeGames();
        }

        async function fetchNFLProps() {
            await fetchRealNFLProps();
        }

        function processNFLProps(apiData) {
            const props = [];
            
            apiData.forEach(game => {
                if (game.bookmakers && game.bookmakers.length > 0) {
                    const bookmaker = game.bookmakers[0];
                    
                    bookmaker.markets.forEach(market => {
                        market.outcomes.forEach(outcome => {
                            if (outcome.description && outcome.point !== undefined) {
                                props.push({
                                    id: Math.random().toString(36),
                                    player: outcome.description,
                                    prop_type: getMarketDisplayName(market.key),
                                    line: outcome.point,
                                    odds: outcome.price,
                                    game: `${game.away_team} @ ${game.home_team}`,
                                    commence_time: game.commence_time
                                });
                            }
                        });
                    });
                }
            });
            
            return props;
        }

        function processCollegeGames(apiData) {
            return apiData.map(game => ({
                id: game.id,
                home_team: game.home_team,
                away_team: game.away_team,
                commence_time: game.commence_time,
                spreads: game.bookmakers?.[0]?.markets?.find(m => m.key === 'spreads')?.outcomes || [],
                totals: game.bookmakers?.[0]?.markets?.find(m => m.key === 'totals')?.outcomes || []
            }));
        }

        function generateSampleNFLProps() {
            // Return placeholder data until real API is connected
            return [
                {
                    id: 'demo1',
                    player: '[Demo] Get API Key for Real Players',
                    prop_type: 'Sample Data Only',
                    line: 0,
                    odds: -110,
                    game: 'Set up API key in Settings tab â†’',
                    commence_time: new Date().toISOString()
                }
            ];
        }

        async function generateSampleCollegeGames() {
            // Return properly formatted array for demo
            return [
                {
                    id: 'demo1',
                    home_team: '[Demo] Add API Key for Real Games',
                    away_team: '[Demo] Sample Data Only',
                    commence_time: new Date(Date.now() + 259200000).toISOString(),
                    spreads: [
                        {name: '[Demo] Team A', point: -7.0, price: -110},
                        {name: '[Demo] Team B', point: 7.0, price: -110}
                    ],
                    totals: [
                        {name: 'Over', point: 45.5, price: -110},
                        {name: 'Under', point: 45.5, price: -110}
                    ]
                }
            ];
        }

        // Real data fetching function for college games
        async function fetchRealCollegeGames() {
            try {
                // First, let's get the real college football games
                const response = await fetch(`https://api.the-odds-api.com/v4/sports/americanfootball_ncaaf/odds/?apiKey=${apiKey}&regions=us&markets=spreads,totals&oddsFormat=american`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Raw college data:', data); // Debug log
                
                if (!data || data.length === 0) {
                    throw new Error('No college games available');
                }
                
                collegeGamesData = data.map(game => ({
                    id: game.id,
                    home_team: game.home_team,
                    away_team: game.away_team,
                    commence_time: game.commence_time,
                    spreads: game.bookmakers?.[0]?.markets?.find(m => m.key === 'spreads')?.outcomes || [],
                    totals: game.bookmakers?.[0]?.markets?.find(m => m.key === 'totals')?.outcomes || []
                }));
                
                updateStatus(`âœ… Loaded ${collegeGamesData.length} real college football games`);
                
            } catch (error) {
                console.error('College games fetch error:', error);
                updateStatus(`âŒ Error loading college games: ${error.message}`);
                
                // Create better fallback with disclaimer
                collegeGamesData = [
                    {
                        id: 'demo1',
                        home_team: '[Demo] Add API Key for Real Games',
                        away_team: '[Demo] Sample Data Only',
                        commence_time: new Date(Date.now() + 259200000).toISOString(),
                        spreads: [
                            {name: '[Demo] Team A', point: -7.0, price: -110},
                            {name: '[Demo] Team B', point: 7.0, price: -110}
                        ],
                        totals: [
                            {name: 'Over', point: 45.5, price: -110},
                            {name: 'Under', point: 45.5, price: -110}
                        ]
                    }
                ];
            }
        }

        // Real data fetching function for NFL props  
        async function fetchRealNFLProps() {
            try {
                const response = await fetch(`https://api.the-odds-api.com/v4/sports/americanfootball_nfl/odds/?apiKey=${apiKey}&regions=us&markets=player_pass_yds,player_rush_yds,player_receiving_yds,player_receptions&oddsFormat=american`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Raw NFL data:', data); // Debug log
                
                if (!data || data.length === 0) {
                    throw new Error('No NFL games with props available');
                }
                
                nflPropsData = processNFLProps(data);
                updateStatus(`âœ… Loaded ${nflPropsData.length} real NFL player props`);
                
            } catch (error) {
                console.error('NFL props fetch error:', error);
                updateStatus(`âŒ Error loading NFL props: ${error.message}`);
                
                // Better fallback
                nflPropsData = [
                    {
                        id: 'demo1',
                        player: '[Demo] Add API Key for Real Players',
                        prop_type: 'Sample Data Only',
                        line: 0,
                        odds: -110,
                        game: 'Get API key from the-odds-api.com',
                        commence_time: new Date().toISOString()
                    }
                ];
            }
        }

        function getMarketDisplayName(marketKey) {
            const names = {
                'player_pass_yds': 'Passing Yards',
                'player_rush_yds': 'Rushing Yards', 
                'player_receiving_yds': 'Receiving Yards',
                'player_receptions': 'Receptions'
            };
            return names[marketKey] || marketKey;
        }

        function runAIAnalysis() {
            updateStatus('ðŸ§  Running AI analysis on all bets...');
            
            // Add AI predictions to NFL props
            nflPropsData = nflPropsData.map(prop => ({
                ...prop,
                ...generateAIPrediction(prop, 'NFL_PROP')
            }));
            
            // Add AI predictions to college games
            collegeGamesData = collegeGamesData.map(game => ({
                ...game,
                spread_analysis: generateAIPrediction({...game, type: 'spread'}, 'COLLEGE_SPREAD'),
                total_analysis: generateAIPrediction({...game, type: 'total'}, 'COLLEGE_TOTAL')
            }));
            
            renderNFLProps();
            renderCollegeGames();
            updateDashboard();
            updateStatus('âœ… AI analysis complete! Check the updated predictions.');
        }

        function generateAIPrediction(data, type) {
            // Simulate realistic AI analysis
            const baseConfidence = 60 + Math.random() * 35; // 60-95%
            const edge = (Math.random() - 0.4) * 25; // -10% to +15% edge
            
            // Grade based on confidence + edge
            const totalScore = baseConfidence + Math.max(0, edge);
            let grade;
            if (totalScore >= 95) grade = 'A+';
            else if (totalScore >= 90) grade = 'A';
            else if (totalScore >= 85) grade = 'A-';
            else if (totalScore >= 80) grade = 'B+';
            else if (totalScore >= 75) grade = 'B';
            else if (totalScore >= 70) grade = 'B-';
            else if (totalScore >= 65) grade = 'C+';
            else if (totalScore >= 60) grade = 'C';
            else if (totalScore >= 55) grade = 'C-';
            else if (totalScore >= 50) grade = 'D';
            else grade = 'F';

            const recommendations = ['OVER', 'UNDER'];
            const recommendation = recommendations[Math.floor(Math.random() * 2)];
            
            // Generate relevant AI factors
            let factors = [];
            if (type === 'NFL_PROP') {
                factors = AI_FACTORS.NFL_PROPS.slice(0, 3 + Math.floor(Math.random() * 3));
            } else {
                factors = AI_FACTORS.COLLEGE_GAMES.slice(0, 4 + Math.floor(Math.random() * 4));
            }
            
            return {
                confidence: Math.round(baseConfidence),
                edge: Math.round(edge * 10) / 10,
                grade: grade,
                recommendation: recommendation,
                predicted_value: type === 'NFL_PROP' ? 
                    Math.round((data.line + (Math.random() - 0.5) * 20) * 10) / 10 : null,
                ai_factors: factors
            };
        }

        function applyFilters(sport) {
            if (sport === 'nfl') {
                renderNFLProps();
            } else if (sport === 'college') {
                renderCollegeBets();
            }
        }

        function renderCollegeGames() {
            // This function is now replaced by renderCollegeBets
            renderCollegeBets();
        }

        function filterAndSortData(data, sport) {
            const dateFrom = document.getElementById(`${sport}-date-from`).value;
            const dateTo = document.getElementById(`${sport}-date-to`).value;
            const sortBy = document.getElementById(`${sport}-sort`).value;
            const minGrade = document.getElementById(`${sport}-min-grade`).value;

            let filteredData = [...data];

            // Date filtering
            if (dateFrom || dateTo) {
                filteredData = filteredData.filter(item => {
                    const itemDate = new Date(item.commence_time);
                    const fromDate = dateFrom ? new Date(dateFrom) : new Date(0);
                    const toDate = dateTo ? new Date(dateTo + 'T23:59:59') : new Date('2030-12-31');
                    return itemDate >= fromDate && itemDate <= toDate;
                });
            }

            // Grade filtering
            if (minGrade) {
                filteredData = filteredData.filter(item => {
                    if (sport === 'nfl') {
                        return item.grade && item.grade.startsWith(minGrade);
                    } else {
                        return (item.spread_analysis?.grade?.startsWith(minGrade)) || 
                               (item.total_analysis?.grade?.startsWith(minGrade));
                    }
                });
            }

            // Sorting
            filteredData.sort((a, b) => {
                if (sortBy === 'grade-desc') {
                    const gradeOrder = {'A+': 13, 'A': 12, 'A-': 11, 'B+': 10, 'B': 9, 'B-': 8, 'C+': 7, 'C': 6, 'C-': 5, 'D': 4, 'F': 3};
                    if (sport === 'nfl') {
                        return (gradeOrder[b.grade] || 0) - (gradeOrder[a.grade] || 0);
                    } else {
                        const aMaxGrade = Math.max(gradeOrder[a.spread_analysis?.grade] || 0, gradeOrder[a.total_analysis?.grade] || 0);
                        const bMaxGrade = Math.max(gradeOrder[b.spread_analysis?.grade] || 0, gradeOrder[b.total_analysis?.grade] || 0);
                        return bMaxGrade - aMaxGrade;
                    }
                } else if (sortBy === 'grade-asc') {
                    const gradeOrder = {'A+': 13, 'A': 12, 'A-': 11, 'B+': 10, 'B': 9, 'B-': 8, 'C+': 7, 'C': 6, 'C-': 5, 'D': 4, 'F': 3};
                    if (sport === 'nfl') {
                        return (gradeOrder[a.grade] || 0) - (gradeOrder[b.grade] || 0);
                    } else {
                        const aMaxGrade = Math.max(gradeOrder[a.spread_analysis?.grade] || 0, gradeOrder[a.total_analysis?.grade] || 0);
                        const bMaxGrade = Math.max(gradeOrder[b.spread_analysis?.grade] || 0, gradeOrder[b.total_analysis?.grade] || 0);
                        return aMaxGrade - bMaxGrade;
                    }
                } else if (sortBy === 'confidence') {
                    if (sport === 'nfl') {
                        return (b.confidence || 0) - (a.confidence || 0);
                    } else {
                        const aMaxConf = Math.max(a.spread_analysis?.confidence || 0, a.total_analysis?.confidence || 0);
                        const bMaxConf = Math.max(b.spread_analysis?.confidence || 0, b.total_analysis?.confidence || 0);
                        return bMaxConf - aMaxConf;
                    }
                } else if (sortBy === 'edge') {
                    if (sport === 'nfl') {
                        return (b.edge || 0) - (a.edge || 0);
                    } else {
                        const aMaxEdge = Math.max(a.spread_analysis?.edge || 0, a.total_analysis?.edge || 0);
                        const bMaxEdge = Math.max(b.spread_analysis?.edge || 0, b.total_analysis?.edge || 0);
                        return bMaxEdge - aMaxEdge;
                    }
                }
                return 0;
            });

            return filteredData;
        }

        function renderNFLProps() {
            const container = document.getElementById('nfl-props-container');
            container.innerHTML = '';

            if (nflPropsData.length === 0) {
                container.innerHTML = '<div class="loading">No NFL props loaded. Click "Fetch Live Data" first.</div>';
                return;
            }

            const filteredData = filterAndSortData(nflPropsData, 'nfl');

            if (filteredData.length === 0) {
                container.innerHTML = '<div class="loading">No props match your filters. Try adjusting date range or grade filters.</div>';
                return;
            }

            filteredData.forEach(prop => {
                const propCard = document.createElement('div');
                propCard.className = 'prop-card';
                
                const gradeClass = prop.grade ? prop.grade.toLowerCase().replace(/[+-]/g, '') : 'c';
                const gameTime = new Date(prop.commence_time).toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short', 
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });
                
                propCard.innerHTML = `
                    <div class="prop-header">
                        <div class="player-name">${prop.player}</div>
                        <div class="prop-type">${prop.prop_type}</div>
                    </div>
                    <div class="prop-details">
                        <div class="prop-line">Line: ${prop.line}</div>
                        <div class="recommendation-badge rec-${prop.recommendation ? prop.recommendation.toLowerCase() : 'pass'}">
                            ${prop.recommendation || 'ANALYZING...'}
                        </div>
                    </div>
                    ${prop.predicted_value ? `<div style="color: #e2e8f0; margin-bottom: 12px; font-size: 16px;">ðŸŽ¯ AI Prediction: ${prop.predicted_value}</div>` : ''}
                    <div style="font-size: 13px; color: #94a3b8; margin-bottom: 16px;">ðŸ“… ${prop.game} â€¢ ${gameTime}</div>
                    ${prop.confidence ? `
                    <div class="confidence-section">
                        <div class="confidence-bar">
                            <div class="confidence-fill" style="width: ${prop.confidence}%"></div>
                        </div>
                        <div class="confidence-info">
                            <div class="confidence-text">${prop.confidence}% Confidence</div>
                            <div class="grade-badge grade-${gradeClass}">${prop.grade}</div>
                        </div>
                    </div>
                    <div class="edge-badge ${prop.edge > 0 ? 'edge-positive' : 'edge-negative'}">
                        ${prop.edge > 0 ? '+' : ''}${prop.edge}% Edge
                    </div>
                    ${prop.ai_factors ? `
                    <div class="ai-factors">
                        <div class="factors-title">ðŸ§  AI Analysis Factors:</div>
                        <div>${prop.ai_factors.join(' â€¢ ')}</div>
                    </div>` : ''}
                    ` : '<div style="color: #94a3b8; text-align: center; padding: 20px;">Click "Run AI Analysis" for predictions</div>'}
                `;
                container.appendChild(propCard);
            });
        }

        function renderCollegeGames() {
            const container = document.getElementById('college-games-container');
            container.innerHTML = '';

            if (collegeGamesData.length === 0) {
                container.innerHTML = '<div class="loading">No college games loaded. Click "Fetch Live Data" first.</div>';
                return;
            }

            const filteredData = filterAndSortData(collegeGamesData, 'college');

            if (filteredData.length === 0) {
                container.innerHTML = '<div class="loading">No games match your filters. Try adjusting date range or grade filters.</div>';
                return;
            }

            filteredData.forEach(game => {
                const gameCard = document.createElement('div');
                gameCard.className = 'game-card';
                
                const gameTime = new Date(game.commence_time).toLocaleDateString('en-US', {
                    weekday: 'long',
                    month: 'short',
                    day: 'numeric', 
                    hour: 'numeric',
                    minute: '2-digit'
                });

                // Format spread line
                let spreadLine = 'No spread available';
                if (game.spreads && game.spreads.length > 0) {
                    const spread = game.spreads.find(s => s.point < 0) || game.spreads[0];
                    spreadLine = `${spread.name} ${spread.point > 0 ? '+' : ''}${spread.point}`;
                }
                
                // Format total line  
                let totalLine = 'No total available';
                if (game.totals && game.totals.length > 0) {
                    totalLine = `${game.totals[0].point}`;
                }
                
                const spreadGrade = game.spread_analysis?.grade || null;
                const totalGrade = game.total_analysis?.grade || null;
                
                gameCard.innerHTML = `
                    <div class="game-header">
                        <div class="teams">
                            <div class="team">${game.away_team}</div>
                            <div class="vs">@</div>
                            <div class="team">${game.home_team}</div>
                        </div>
                        <div class="game-time">${gameTime}</div>
                    </div>
                    <div class="predictions">
                        <div class="prediction">
                            <div class="prediction-type">Point Spread</div>
                            <div class="prediction-value">${spreadLine}</div>
                            ${game.spread_analysis ? `
                            <div class="confidence-section">
                                <div class="confidence-bar">
                                    <div class="confidence-fill" style="width: ${game.spread_analysis.confidence}%"></div>
                                </div>
                                <div class="confidence-info">
                                    <div class="confidence-text">${game.spread_analysis.confidence}% Confidence</div>
                                    <div class="grade-badge grade-${spreadGrade.toLowerCase().replace(/[+-]/g, '')}">${spreadGrade}</div>
                                </div>
                            </div>
                            <div class="edge-badge ${game.spread_analysis.edge > 0 ? 'edge-positive' : 'edge-negative'}">
                                ${game.spread_analysis.edge > 0 ? '+' : ''}${game.spread_analysis.edge}% Edge
                            </div>
                            <div class="ai-factors">
                                <div class="factors-title">ðŸ§  Key Factors:</div>
                                <div>${game.spread_analysis.ai_factors.slice(0, 3).join(' â€¢ ')}</div>
                            </div>
                            ` : '<div style="color: #94a3b8; text-align: center; padding: 20px;">Click "Run AI Analysis" for predictions</div>'}
                        </div>
                        <div class="prediction">
                            <div class="prediction-type">Total Points</div>
                            <div class="prediction-value">${game.total_analysis?.recommendation || 'Over'} ${totalLine}</div>
                            ${game.total_analysis ? `
                            <div class="confidence-section">
                                <div class="confidence-bar">
                                    <div class="confidence-fill" style="width: ${game.total_analysis.confidence}%"></div>
                                </div>
                                <div class="confidence-info">
                                    <div class="confidence-text">${game.total_analysis.confidence}% Confidence</div>
                                    <div class="grade-badge grade-${totalGrade.toLowerCase().replace(/[+-]/g, '')}">${totalGrade}</div>
                                </div>
                            </div>
                            <div class="edge-badge ${game.total_analysis.edge > 0 ? 'edge-positive' : 'edge-negative'}">
                                ${game.total_analysis.edge > 0 ? '+' : ''}${game.total_analysis.edge}% Edge
                            </div>
                            <div class="ai-factors">
                                <div class="factors-title">ðŸ§  Key Factors:</div>
                                <div>${game.total_analysis.ai_factors.slice(0, 3).join(' â€¢ ')}</div>
                            </div>
                            ` : '<div style="color: #94a3b8; text-align: center; padding: 20px;">Click "Run AI Analysis" for predictions</div>'}
                        </div>
                    </div>
                `;
                container.appendChild(gameCard);
            });
        }

        function renderAPlusBets() {
            const container = document.getElementById('a-plus-container');
            container.innerHTML = '';

            // Get all A+ bets
            const aPlusNFLProps = nflPropsData.filter(p => p.grade === 'A+');
            const aPlusCollegeGames = collegeGamesData.filter(g => 
                g.spread_analysis?.grade === 'A+' || g.total_analysis?.grade === 'A+'
            );

            if (aPlusNFLProps.length === 0 && aPlusCollegeGames.length === 0) {
                container.innerHTML = '<div class="loading">ðŸ” No A+ grade bets found. Run AI analysis to find top opportunities!</div>';
                return;
            }

            // Create sections for different bet types
            if (aPlusNFLProps.length > 0) {
                const nflSection = document.createElement('div');
                nflSection.innerHTML = '<h3 style="margin: 20px 0; color: #00d4ff;">ðŸˆ A+ NFL Player Props</h3>';
                container.appendChild(nflSection);

                const nflGrid = document.createElement('div');
                nflGrid.className = 'props-grid';
                
                aPlusNFLProps.forEach(prop => {
                    const propCard = document.createElement('div');
                    propCard.className = 'prop-card';
                    propCard.style.border = '2px solid #10b981';
                    
                    const gameTime = new Date(prop.commence_time).toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric',
                        hour: 'numeric',
                        minute: '2-digit'
                    });
                    
                    propCard.innerHTML = `
                        <div class="prop-header">
                            <div class="player-name">${prop.player}</div>
                            <div class="prop-type">${prop.prop_type}</div>
                        </div>
                        <div class="prop-details">
                            <div class="prop-line">Line: ${prop.line}</div>
                            <div class="recommendation-badge rec-${prop.recommendation.toLowerCase()}">
                                ${prop.recommendation}
                            </div>
                        </div>
                        <div style="color: #e2e8f0; margin-bottom: 12px; font-size: 16px;">ðŸŽ¯ AI Prediction: ${prop.predicted_value}</div>
                        <div style="font-size: 13px; color: #94a3b8; margin-bottom: 16px;">ðŸ“… ${prop.game} â€¢ ${gameTime}</div>
                        <div class="confidence-section">
                            <div class="confidence-bar">
                                <div class="confidence-fill" style="width: ${prop.confidence}%"></div>
                            </div>
                            <div class="confidence-info">
                                <div class="confidence-text">${prop.confidence}% Confidence</div>
                                <div class="grade-badge grade-a">${prop.grade}</div>
                            </div>
                        </div>
                        <div class="edge-badge edge-positive">
                            +${prop.edge}% Edge
                        </div>
                        <div class="ai-factors">
                            <div class="factors-title">ðŸ§  AI Analysis Factors:</div>
                            <div>${prop.ai_factors.join(' â€¢ ')}</div>
                        </div>
                    `;
                    nflGrid.appendChild(propCard);
                });
                container.appendChild(nflGrid);
            }

            if (aPlusCollegeGames.length > 0) {
                const collegeSection = document.createElement('div');
                collegeSection.innerHTML = '<h3 style="margin: 40px 0 20px 0; color: #ff006e;">ðŸ« A+ College Football Games</h3>';
                container.appendChild(collegeSection);

                const collegeGrid = document.createElement('div');
                collegeGrid.className = 'games-grid';
                
                aPlusCollegeGames.forEach(game => {
                    const gameCard = document.createElement('div');
                    gameCard.className = 'game-card';
                    gameCard.style.border = '2px solid #10b981';
                    
                    const gameTime = new Date(game.commence_time).toLocaleDateString('en-US', {
                        weekday: 'long',
                        month: 'short',
                        day: 'numeric',
                        hour: 'numeric',
                        minute: '2-digit'
                    });

                    let spreadLine = 'No spread';
                    if (game.spreads && game.spreads.length > 0) {
                        const spread = game.spreads.find(s => s.point < 0) || game.spreads[0];
                        spreadLine = `${spread.name} ${spread.point > 0 ? '+' : ''}${spread.point}`;
                    }
                    
                    let totalLine = 'No total';
                    if (game.totals && game.totals.length > 0) {
                        totalLine = `${game.totals[0].point}`;
                    }
                    
                    gameCard.innerHTML = `
                        <div class="game-header">
                            <div class="teams">
                                <div class="team">${game.away_team}</div>
                                <div class="vs">@</div>
                                <div class="team">${game.home_team}</div>
                            </div>
                            <div class="game-time">${gameTime}</div>
                        </div>
                        <div class="predictions">
                            ${game.spread_analysis?.grade === 'A+' ? `
                            <div class="prediction">
                                <div class="prediction-type">Point Spread â­</div>
                                <div class="prediction-value">${spreadLine}</div>
                                <div class="confidence-section">
                                    <div class="confidence-bar">
                                        <div class="confidence-fill" style="width: ${game.spread_analysis.confidence}%"></div>
                                    </div>
                                    <div class="confidence-info">
                                        <div class="confidence-text">${game.spread_analysis.confidence}% Confidence</div>
                                        <div class="grade-badge grade-a">${game.spread_analysis.grade}</div>
                                    </div>
                                </div>
                                <div class="edge-badge edge-positive">
                                    +${game.spread_analysis.edge}% Edge
                                </div>
                            </div>` : ''}
                            ${game.total_analysis?.grade === 'A+' ? `
                            <div class="prediction">
                                <div class="prediction-type">Total Points â­</div>
                                <div class="prediction-value">${game.total_analysis.recommendation} ${totalLine}</div>
                                <div class="confidence-section">
                                    <div class="confidence-bar">
                                        <div class="confidence-fill" style="width: ${game.total_analysis.confidence}%"></div>
                                    </div>
                                    <div class="confidence-info">
                                        <div class="confidence-text">${game.total_analysis.confidence}% Confidence</div>
                                        <div class="grade-badge grade-a">${game.total_analysis.grade}</div>
                                    </div>
                                </div>
                                <div class="edge-badge edge-positive">
                                    +${game.total_analysis.edge}% Edge
                                </div>
                            </div>` : ''}
                        </div>
                    `;
                    collegeGrid.appendChild(gameCard);
                });
                container.appendChild(collegeGrid);
            }
        }

        function updateDashboard() {
            const totalProps = nflPropsData.length;
            const totalCollege = collegeGamesData.length;
            
            // Count A+ grade bets
            const aPlusProps = nflPropsData.filter(p => p.grade === 'A+').length;
            const aPlusGames = collegeGamesData.filter(g => 
                g.spread_analysis?.grade === 'A+' || g.total_analysis?.grade === 'A+'
            ).length;
            const totalAPlus = aPlusProps + aPlusGames;
            
            // Calculate average edge
            const allEdges = [
                ...nflPropsData.filter(p => p.edge !== undefined).map(p => p.edge),
                ...collegeGamesData.filter(g => g.spread_analysis?.edge !== undefined).map(g => g.spread_analysis.edge),
                ...collegeGamesData.filter(g => g.total_analysis?.edge !== undefined).map(g => g.total_analysis.edge)
            ];
            
            const avgEdge = allEdges.length > 0 ? 
                Math.round((allEdges.reduce((a, b) => a + b, 0) / allEdges.length) * 10) / 10 : 0;
            
            document.getElementById('total-props').textContent = totalProps;
            document.getElementById('total-college').textContent = totalCollege;
            document.getElementById('a-grade-bets').textContent = totalAPlus;
            document.getElementById('avg-edge').textContent = avgEdge > 0 ? `+${avgEdge}%` : `${avgEdge}%`;
        }

        // Prediction tracking functions
        function lockPredictions() {
            const now = new Date();
            const thirtyMinutes = 30 * 60 * 1000; // 30 minutes in milliseconds
            
            // Check NFL props for locking
            nflPropsData.forEach(prop => {
                const gameTime = new Date(prop.commence_time);
                const lockTime = new Date(gameTime.getTime() - thirtyMinutes);
                
                if (now >= lockTime && prop.grade && !isAlreadyLocked(prop.id)) {
                    const lockedPrediction = {
                        id: prop.id,
                        type: 'nfl-prop',
                        player: prop.player,
                        propType: prop.prop_type,
                        line: prop.line,
                        recommendation: prop.recommendation,
                        grade: prop.grade,
                        confidence: prop.confidence,
                        edge: prop.edge,
                        game: prop.game,
                        gameTime: prop.commence_time,
                        lockedAt: now.toISOString(),
                        status: 'locked',
                        sport: 'NFL',
                        betDetails: {
                            category: 'Player Prop',
                            position: getPlayerPosition(prop.prop_type),
                            propCategory: prop.prop_type,
                            homeAway: prop.game.includes('@') ? 'away' : 'home'
                        }
                    };
                    lockedPredictions.push(lockedPrediction);
                }
            });
            
            // Check college games for locking
            collegeGamesData.forEach(game => {
                const gameTime = new Date(game.commence_time);
                const lockTime = new Date(gameTime.getTime() - thirtyMinutes);
                
                if (now >= lockTime) {
                    // Lock spread prediction
                    if (game.spread_analysis && game.spread_analysis.grade && !isAlreadyLocked(game.id + '_spread')) {
                        const spreadLine = game.spreads[0] ? `${game.spreads[0].name} ${game.spreads[0].point}` : 'No spread';
                        const isUnderdog = game.spreads[0] && game.spreads[0].point > 0;
                        const isHome = game.spreads[0] && game.spreads[0].name === game.home_team;
                        
                        lockedPredictions.push({
                            id: game.id + '_spread',
                            type: 'college-spread',
                            game: `${game.away_team} @ ${game.home_team}`,
                            prediction: spreadLine,
                            grade: game.spread_analysis.grade,
                            confidence: game.spread_analysis.confidence,
                            edge: game.spread_analysis.edge,
                            gameTime: game.commence_time,
                            lockedAt: now.toISOString(),
                            status: 'locked',
                            sport: 'College',
                            betDetails: {
                                category: 'Game Spread',
                                favoriteUnderdog: isUnderdog ? 'Underdog' : 'Favorite',
                                homeAway: isHome ? 'Home' : 'Away'
                            }
                        });
                    }
                    
                    // Lock total prediction
                    if (game.total_analysis && game.total_analysis.grade && !isAlreadyLocked(game.id + '_total')) {
                        const totalLine = game.totals[0] ? `${game.total_analysis.recommendation} ${game.totals[0].point}` : 'No total';
                        
                        lockedPredictions.push({
                            id: game.id + '_total',
                            type: 'college-total',
                            game: `${game.away_team} @ ${game.home_team}`,
                            prediction: totalLine,
                            grade: game.total_analysis.grade,
                            confidence: game.total_analysis.confidence,
                            edge: game.total_analysis.edge,
                            gameTime: game.commence_time,
                            lockedAt: now.toISOString(),
                            status: 'locked',
                            sport: 'College',
                            betDetails: {
                                category: 'Game Total',
                                overUnder: game.total_analysis.recommendation
                            }
                        });
                    }
                }
            });
            
            // Save to localStorage
            localStorage.setItem('lockedPredictions', JSON.stringify(lockedPredictions));
        }
        
        function isAlreadyLocked(predictionId) {
            return lockedPredictions.some(pred => pred.id === predictionId);
        }
        
        function getPlayerPosition(propType) {
            if (propType.includes('Pass')) return 'QB';
            if (propType.includes('Rush')) return 'RB/QB';
            if (propType.includes('Receiv') || propType.includes('Recept')) return 'WR/TE';
            return 'Unknown';
        }
        
        function checkForCompletedGames() {
            const now = new Date();
            let completedCount = 0;
            
            lockedPredictions.forEach(prediction => {
                const gameTime = new Date(prediction.gameTime);
                const gameEndTime = new Date(gameTime.getTime() + (4 * 60 * 60 * 1000)); // Assume 4 hours for game completion
                
                if (now >= gameEndTime && prediction.status === 'locked') {
                    // Simulate result for demo purposes
                    const wonGame = Math.random() > 0.3; // 70% win rate simulation
                    prediction.status = wonGame ? 'won' : 'lost';
                    prediction.result = wonGame ? 'WIN' : 'LOSS';
                    prediction.completedAt = now.toISOString();
                    completedCount++;
                }
            });
            
            if (completedCount > 0) {
                localStorage.setItem('lockedPredictions', JSON.stringify(lockedPredictions));
                updateStatus(`âœ… Found ${completedCount} completed games. Results updated!`);
                renderResultsTables();
                renderLockedPredictions();
            } else {
                updateStatus(`â„¹ï¸ No new completed games found.`);
            }
        }
        
        function simulateResults() {
            // Add some demo completed predictions for testing
            const demoResults = [
                {
                    id: 'demo1', type: 'nfl-prop', player: 'Demo Player', grade: 'A+', 
                    status: 'won', sport: 'NFL', betDetails: { category: 'Player Prop', position: 'QB', propCategory: 'Passing Yards' }
                },
                {
                    id: 'demo2', type: 'college-spread', game: 'Demo Game', grade: 'A', 
                    status: 'won', sport: 'College', betDetails: { category: 'Game Spread', favoriteUnderdog: 'Underdog', homeAway: 'Away' }
                },
                {
                    id: 'demo3', type: 'nfl-prop', player: 'Demo Player 2', grade: 'B+', 
                    status: 'lost', sport: 'NFL', betDetails: { category: 'Player Prop', position: 'RB', propCategory: 'Rushing Yards' }
                },
                {
                    id: 'demo4', type: 'college-total', game: 'Demo Game 2', grade: 'A-', 
                    status: 'won', sport: 'College', betDetails: { category: 'Game Total', overUnder: 'Over' }
                }
            ];
            
            demoResults.forEach(demo => {
                if (!lockedPredictions.some(p => p.id === demo.id)) {
                    lockedPredictions.push({
                        ...demo,
                        gameTime: new Date(Date.now() - 86400000).toISOString(),
                        lockedAt: new Date(Date.now() - 90000000).toISOString(),
                        completedAt: new Date(Date.now() - 82800000).toISOString()
                    });
                }
            });
            
            localStorage.setItem('lockedPredictions', JSON.stringify(lockedPredictions));
            updateStatus(`âœ… Added demo results for testing!`);
            renderResultsTables();
            renderLockedPredictions();
        }
        
        function renderResultsTables() {
            renderGradeResultsTable();
            renderTypeResultsTable();
        }
        
        function renderGradeResultsTable() {
            const gradeStats = {};
            
            lockedPredictions.filter(p => p.status === 'won' || p.status === 'lost').forEach(prediction => {
                if (!gradeStats[prediction.grade]) {
                    gradeStats[prediction.grade] = { wins: 0, total: 0 };
                }
                gradeStats[prediction.grade].total++;
                if (prediction.status === 'won') {
                    gradeStats[prediction.grade].wins++;
                }
            });
            
            const tbody = document.getElementById('grade-results-table');
            if (Object.keys(gradeStats).length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #94a3b8;">No completed predictions yet</td></tr>';
                return;
            }
            
            const gradeOrder = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'D', 'F'];
            const sortedGrades = Object.keys(gradeStats).sort((a, b) => gradeOrder.indexOf(a) - gradeOrder.indexOf(b));
            
            tbody.innerHTML = sortedGrades.map(grade => {
                const stats = gradeStats[grade];
                const winRate = ((stats.wins / stats.total) * 100).toFixed(1);
                const winRateClass = winRate >= 80 ? 'win-rate-high' : winRate >= 60 ? 'win-rate-medium' : 'win-rate-low';
                
                return `
                    <tr>
                        <td><span class="grade-badge grade-${grade.toLowerCase().replace(/[+-]/g, '')}">${grade}</span></td>
                        <td class="${winRateClass}">${winRate}%</td>
                        <td>${stats.wins}-${stats.total - stats.wins}</td>
                        <td>${stats.total}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function renderTypeResultsTable() {
            const typeStats = {};
            
            lockedPredictions.filter(p => p.status === 'won' || p.status === 'lost').forEach(prediction => {
                const key = createBetTypeKey(prediction);
                if (!typeStats[key]) {
                    typeStats[key] = { 
                        wins: 0, total: 0, 
                        sport: prediction.sport,
                        details: prediction.betDetails,
                        description: createBetDescription(prediction)
                    };
                }
                typeStats[key].total++;
                if (prediction.status === 'won') {
                    typeStats[key].wins++;
                }
            });
            
            const tbody = document.getElementById('type-results-table');
            if (Object.keys(typeStats).length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #94a3b8;">No completed predictions yet</td></tr>';
                return;
            }
            
            const sortedTypes = Object.entries(typeStats)
                .map(([key, stats]) => ({ key, ...stats, winRate: (stats.wins / stats.total) * 100 }))
                .sort((a, b) => b.winRate - a.winRate)
                .slice(0, 20);
            
            tbody.innerHTML = sortedTypes.map((type, index) => {
                const winRateClass = type.winRate >= 80 ? 'win-rate-high' : type.winRate >= 60 ? 'win-rate-medium' : 'win-rate-low';
                
                return `
                    <tr>
                        <td>#${index + 1}</td>
                        <td class="${winRateClass}">${type.winRate.toFixed(1)}%</td>
                        <td>${type.wins}/${type.total}</td>
                        <td>${type.sport}</td>
                        <td style="font-size: 11px;">${type.description}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function createBetTypeKey(prediction) {
            const details = prediction.betDetails;
            return `${prediction.sport}_${details.category}_${Object.values(details).join('_')}`;
        }
        
        function createBetDescription(prediction) {
            const d = prediction.betDetails;
            if (d.category === 'Player Prop') {
                return `${d.propCategory}, ${d.position}, ${d.homeAway}`;
            } else if (d.category === 'Game Spread') {
                return `Spread, ${d.favoriteUnderdog}, ${d.homeAway}`;
            } else if (d.category === 'Game Total') {
                return `Total, ${d.overUnder}`;
            }
            return 'Unknown';
        }
        
        function renderLockedPredictions() {
            const container = document.getElementById('locked-predictions-container');
            const activeLocked = lockedPredictions.filter(p => p.status === 'locked').slice(0, 10);
            
            if (activeLocked.length === 0) {
                container.innerHTML = '<div class="loading">No predictions locked yet. Predictions automatically lock 30 minutes before game time.</div>';
                return;
            }
            
            container.innerHTML = activeLocked.map(prediction => {
                const gameTime = new Date(prediction.gameTime);
                const timeUntilGame = Math.max(0, gameTime.getTime() - Date.now());
                const hoursUntilGame = Math.floor(timeUntilGame / (1000 * 60 * 60));
                const minutesUntilGame = Math.floor((timeUntilGame % (1000 * 60 * 60)) / (1000 * 60));
                
                return `
                    <div class="locked-prediction-card">
                        <div class="prediction-header">
                            <div>
                                <span class="grade-badge grade-${prediction.grade.toLowerCase().replace(/[+-]/g, '')}">${prediction.grade}</span>
                                <strong>${prediction.player || prediction.game}</strong>
                            </div>
                            <div class="prediction-status status-locked">LOCKED</div>
                        </div>
                        <div class="prediction-details">
                            ${prediction.prediction || `${prediction.propType}: ${prediction.recommendation} ${prediction.line}`}
                        </div>
                        <div class="lock-timer">
                            Game in ${hoursUntilGame}h ${minutesUntilGame}m â€¢ Locked ${new Date(prediction.lockedAt).toLocaleString()}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function clearAllData() {
            if (confirm('Are you sure you want to clear all prediction data? This cannot be undone.')) {
                lockedPredictions = [];
                completedGames = [];
                localStorage.removeItem('lockedPredictions');
                localStorage.removeItem('completedGames');
                updateStatus('âœ… All prediction data cleared');
                renderResultsTables();
                renderLockedPredictions();
            }
        }
        function performSearch() {
            const query = document.getElementById('global-search').value.toLowerCase().trim();
            const resultsContainer = document.getElementById('search-results');
            
            if (query.length < 2) {
                resultsContainer.style.display = 'none';
                return;
            }
            
            const results = [];
            
            // Search NFL props
            nflPropsData.forEach(prop => {
                if (prop.player.toLowerCase().includes(query) || 
                    prop.game.toLowerCase().includes(query) ||
                    prop.prop_type.toLowerCase().includes(query)) {
                    results.push({
                        title: prop.player,
                        subtitle: `${prop.prop_type} - ${prop.game}`,
                        type: 'nfl-prop',
                        data: prop
                    });
                }
            });
            
            // Search college games
            collegeGamesData.forEach(game => {
                if (game.home_team.toLowerCase().includes(query) || 
                    game.away_team.toLowerCase().includes(query)) {
                    results.push({
                        title: `${game.away_team} @ ${game.home_team}`,
                        subtitle: `College Football - ${new Date(game.commence_time).toLocaleDateString()}`,
                        type: 'college-game',
                        data: game
                    });
                }
            });
            
            // Display results
            if (results.length === 0) {
                resultsContainer.innerHTML = '<div class="search-result-item"><div class="search-result-title">No results found</div><div class="search-result-subtitle">Try searching for team names or player names</div></div>';
            } else {
                resultsContainer.innerHTML = results.slice(0, 8).map(result => 
                    `<div class="search-result-item" onmousedown="selectSearchResult('${result.type}', '${result.data.id}')">
                        <div class="search-result-title">${result.title}</div>
                        <div class="search-result-subtitle">${result.subtitle}</div>
                    </div>`
                ).join('');
            }
            
            resultsContainer.style.display = 'block';
        }
        
        function showSearchResults() {
            const query = document.getElementById('global-search').value;
            if (query.length >= 2) {
                document.getElementById('search-results').style.display = 'block';
            }
        }
        
        function hideSearchResults() {
            setTimeout(() => {
                document.getElementById('search-results').style.display = 'none';
            }, 200);
        }
        
        function selectSearchResult(type, id) {
            if (type === 'nfl-prop') {
                switchTab('nfl-props');
                // Scroll to the specific prop
                setTimeout(() => {
                    const propElements = document.querySelectorAll('#nfl-props-container .prop-card');
                    propElements.forEach(card => {
                        if (card.innerHTML.includes(id)) {
                            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            card.style.border = '2px solid #00d4ff';
                            setTimeout(() => {
                                card.style.border = '1px solid rgba(255, 255, 255, 0.12)';
                            }, 3000);
                        }
                    });
                }, 100);
            } else if (type === 'college-game') {
                switchTab('college-games');
                // Scroll to the specific game
                setTimeout(() => {
                    const gameElements = document.querySelectorAll('#college-games-container .game-card');
                    gameElements.forEach(card => {
                        if (card.innerHTML.includes(id)) {
                            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            card.style.border = '2px solid #00d4ff';
                            setTimeout(() => {
                                card.style.border = '1px solid rgba(255, 255, 255, 0.12)';
                            }, 3000);
                        }
                    });
                }, 100);
            }
            
            document.getElementById('global-search').value = '';
            document.getElementById('search-results').style.display = 'none';
        }
        document.addEventListener('DOMContentLoaded', function() {
            loadSettings();
            initializeDateFilters();
            
            // Load sample data initially for demo
            nflPropsData = generateSampleNFLProps();
            collegeGamesData = generateSampleCollegeGames();
            
            // Run AI analysis on sample data
            setTimeout(() => {
                runAIAnalysis();
            }, 1000);
        });

        // Auto-refresh every 10 minutes if API key is set
        setInterval(() => {
            if (apiKey && document.visibilityState === 'visible') {
                fetchAllData();
            }
        }, 600000);
    </script>
</body>
</html>